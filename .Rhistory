plot_ly(data = d, type = "choropleth", locations = d$CountryCode, z = d$variable,
text = paste0(d$CountryName)) %>%
colorbar(title = legend_title) %>%#, x = 0.5, xanchor = "center", y = 1.5) %>%
layout(title = title) %>%
layout(geo = list(lataxis = list(range = c(-30, 150))))
# layout(legend = list(orientation = "h",
#                      xanchor = "center",
#                      x = 0.5))
#add_trace(color = ~variable, type = "choropleth", locations = unique(CountryName))
# ggplot(d, aes(x = long, y = lat)) +
#   geom_polygon(aes(group = group, fill = variable)) +
#   scale_fill_viridis_c(option = 'plasma', limits = c(0, 100), name = legend_title) +
#   scale_x_continuous(expand = c(0, 0)) +
#   scale_y_continuous(expand = c(0, 0)) +
#   ggtitle(title) +
#   theme_bw() +
#   theme(
#     legend.position = 'top',
#     axis.title = element_blank(),
#     axis.text = element_blank(),
#     axis.ticks = element_blank(),
#     panel.grid.minor = element_blank(),
#     panel.grid.major = element_blank(),
#     plot.title = element_text(hjust = 0.5)
#   )
}
plot_world_data(world, dat, "2020-04-23", "StringencyIndex")
#' Returns ggplot of map filled according to variable
#' TODO: Change this to a fast plotly implementation (instead of calling ggplotly on the result)
#' TODO: Scale Deaths and Cases differently for sound visualisation
#'
#' @param world world data
#' @param sdat stringency data
#' @param date date for the stringency index
#' @param variable variable which should be shown
#' @returns ggplot object
plot_world_data <- function(world, dat, date, variable) {
#d <- left_join(world, filter(dat, Date == date), by = c('region' = 'Country'))
d <- filter(dat, Date == date)
if (variable == 'StringencyIndex') {
title <- 'Stringency of Lockdown Across the World'
legend_title <- 'Stringency Index'
d$variable <- d$StringencyIndexForDisplay
} else if (variable == 'Deaths') {
title <- 'Confirmed Deaths per Million Across the World'
legend_title <- 'Deaths per Million'
d$variable <- d$DeathsPerMillion
} else if (variable == 'Cases') {
title <- 'Confirmed Cases per Million Across the World'
legend_title <- 'Cases per Million'
d$variable <- d$CasesPerMillion
}
plot_ly(data = d, type = "choropleth", locations = d$CountryCode, z = d$variable,
text = paste0(d$CountryName)) %>%
colorbar(title = legend_title) %>%#, x = 0.5, xanchor = "center", y = 1.5) %>%
layout(title = title) %>%
layout(geo = list(lataxis = list(range = c(-35, 150))))
# layout(legend = list(orientation = "h",
#                      xanchor = "center",
#                      x = 0.5))
#add_trace(color = ~variable, type = "choropleth", locations = unique(CountryName))
# ggplot(d, aes(x = long, y = lat)) +
#   geom_polygon(aes(group = group, fill = variable)) +
#   scale_fill_viridis_c(option = 'plasma', limits = c(0, 100), name = legend_title) +
#   scale_x_continuous(expand = c(0, 0)) +
#   scale_y_continuous(expand = c(0, 0)) +
#   ggtitle(title) +
#   theme_bw() +
#   theme(
#     legend.position = 'top',
#     axis.title = element_blank(),
#     axis.text = element_blank(),
#     axis.ticks = element_blank(),
#     panel.grid.minor = element_blank(),
#     panel.grid.major = element_blank(),
#     plot.title = element_text(hjust = 0.5)
#   )
}
plot_world_data(world, dat, "2020-04-23", "StringencyIndex")
#' Returns ggplot of map filled according to variable
#' TODO: Change this to a fast plotly implementation (instead of calling ggplotly on the result)
#' TODO: Scale Deaths and Cases differently for sound visualisation
#'
#' @param world world data
#' @param sdat stringency data
#' @param date date for the stringency index
#' @param variable variable which should be shown
#' @returns ggplot object
plot_world_data <- function(world, dat, date, variable) {
#d <- left_join(world, filter(dat, Date == date), by = c('region' = 'Country'))
d <- filter(dat, Date == date)
if (variable == 'StringencyIndex') {
title <- 'Stringency of Lockdown Across the World'
legend_title <- 'Stringency Index'
d$variable <- d$StringencyIndexForDisplay
} else if (variable == 'Deaths') {
title <- 'Confirmed Deaths per Million Across the World'
legend_title <- 'Deaths per Million'
d$variable <- d$DeathsPerMillion
} else if (variable == 'Cases') {
title <- 'Confirmed Cases per Million Across the World'
legend_title <- 'Cases per Million'
d$variable <- d$CasesPerMillion
}
plot_ly(data = d, type = "choropleth", locations = d$CountryCode, z = d$variable,
text = paste0(d$CountryName)) %>%
colorbar(title = legend_title, yanchor = "bottom") %>%#, x = 0.5, xanchor = "center", y = 1.5) %>%
layout(title = title) %>%
layout(geo = list(lataxis = list(range = c(-35, 150))))
# layout(legend = list(orientation = "h",
#                      xanchor = "center",
#                      x = 0.5))
#add_trace(color = ~variable, type = "choropleth", locations = unique(CountryName))
# ggplot(d, aes(x = long, y = lat)) +
#   geom_polygon(aes(group = group, fill = variable)) +
#   scale_fill_viridis_c(option = 'plasma', limits = c(0, 100), name = legend_title) +
#   scale_x_continuous(expand = c(0, 0)) +
#   scale_y_continuous(expand = c(0, 0)) +
#   ggtitle(title) +
#   theme_bw() +
#   theme(
#     legend.position = 'top',
#     axis.title = element_blank(),
#     axis.text = element_blank(),
#     axis.ticks = element_blank(),
#     panel.grid.minor = element_blank(),
#     panel.grid.major = element_blank(),
#     plot.title = element_text(hjust = 0.5)
#   )
}
plot_world_data(world, dat, "2020-04-23", "StringencyIndex")
#' Returns ggplot of map filled according to variable
#' TODO: Change this to a fast plotly implementation (instead of calling ggplotly on the result)
#' TODO: Scale Deaths and Cases differently for sound visualisation
#'
#' @param world world data
#' @param sdat stringency data
#' @param date date for the stringency index
#' @param variable variable which should be shown
#' @returns ggplot object
plot_world_data <- function(world, dat, date, variable) {
#d <- left_join(world, filter(dat, Date == date), by = c('region' = 'Country'))
d <- filter(dat, Date == date)
if (variable == 'StringencyIndex') {
title <- 'Stringency of Lockdown Across the World'
legend_title <- 'Stringency Index'
d$variable <- d$StringencyIndexForDisplay
} else if (variable == 'Deaths') {
title <- 'Confirmed Deaths per Million Across the World'
legend_title <- 'Deaths per Million'
d$variable <- d$DeathsPerMillion
} else if (variable == 'Cases') {
title <- 'Confirmed Cases per Million Across the World'
legend_title <- 'Cases per Million'
d$variable <- d$CasesPerMillion
}
plot_ly(data = d, type = "choropleth", locations = d$CountryCode, z = d$variable,
text = paste0(d$CountryName)) %>%
colorbar(title = legend_title, yanchor = "top") %>%#, x = 0.5, xanchor = "center", y = 1.5) %>%
layout(title = title) %>%
layout(geo = list(lataxis = list(range = c(-35, 150))))
# layout(legend = list(orientation = "h",
#                      xanchor = "center",
#                      x = 0.5))
#add_trace(color = ~variable, type = "choropleth", locations = unique(CountryName))
# ggplot(d, aes(x = long, y = lat)) +
#   geom_polygon(aes(group = group, fill = variable)) +
#   scale_fill_viridis_c(option = 'plasma', limits = c(0, 100), name = legend_title) +
#   scale_x_continuous(expand = c(0, 0)) +
#   scale_y_continuous(expand = c(0, 0)) +
#   ggtitle(title) +
#   theme_bw() +
#   theme(
#     legend.position = 'top',
#     axis.title = element_blank(),
#     axis.text = element_blank(),
#     axis.ticks = element_blank(),
#     panel.grid.minor = element_blank(),
#     panel.grid.major = element_blank(),
#     plot.title = element_text(hjust = 0.5)
#   )
}
plot_world_data(world, dat, "2020-04-23", "StringencyIndex")
#' Returns ggplot of map filled according to variable
#' TODO: Change this to a fast plotly implementation (instead of calling ggplotly on the result)
#' TODO: Scale Deaths and Cases differently for sound visualisation
#'
#' @param world world data
#' @param sdat stringency data
#' @param date date for the stringency index
#' @param variable variable which should be shown
#' @returns ggplot object
plot_world_data <- function(world, dat, date, variable) {
#d <- left_join(world, filter(dat, Date == date), by = c('region' = 'Country'))
d <- filter(dat, Date == date)
if (variable == 'StringencyIndex') {
title <- 'Stringency of Lockdown Across the World'
legend_title <- 'Stringency Index'
d$variable <- d$StringencyIndexForDisplay
} else if (variable == 'Deaths') {
title <- 'Confirmed Deaths per Million Across the World'
legend_title <- 'Deaths per Million'
d$variable <- d$DeathsPerMillion
} else if (variable == 'Cases') {
title <- 'Confirmed Cases per Million Across the World'
legend_title <- 'Cases per Million'
d$variable <- d$CasesPerMillion
}
plot_ly(data = d, type = "choropleth", locations = d$CountryCode, z = d$variable,
text = paste0(d$CountryName)) %>%
colorbar(title = legend_title, y = 1) %>%#, x = 0.5, xanchor = "center", y = 1.5) %>%
layout(title = title) %>%
layout(geo = list(lataxis = list(range = c(-35, 150))))
# layout(legend = list(orientation = "h",
#                      xanchor = "center",
#                      x = 0.5))
#add_trace(color = ~variable, type = "choropleth", locations = unique(CountryName))
# ggplot(d, aes(x = long, y = lat)) +
#   geom_polygon(aes(group = group, fill = variable)) +
#   scale_fill_viridis_c(option = 'plasma', limits = c(0, 100), name = legend_title) +
#   scale_x_continuous(expand = c(0, 0)) +
#   scale_y_continuous(expand = c(0, 0)) +
#   ggtitle(title) +
#   theme_bw() +
#   theme(
#     legend.position = 'top',
#     axis.title = element_blank(),
#     axis.text = element_blank(),
#     axis.ticks = element_blank(),
#     panel.grid.minor = element_blank(),
#     panel.grid.major = element_blank(),
#     plot.title = element_text(hjust = 0.5)
#   )
}
plot_world_data(world, dat, "2020-04-23", "StringencyIndex")
#' Returns ggplot of map filled according to variable
#' TODO: Change this to a fast plotly implementation (instead of calling ggplotly on the result)
#' TODO: Scale Deaths and Cases differently for sound visualisation
#'
#' @param world world data
#' @param sdat stringency data
#' @param date date for the stringency index
#' @param variable variable which should be shown
#' @returns ggplot object
plot_world_data <- function(world, dat, date, variable) {
#d <- left_join(world, filter(dat, Date == date), by = c('region' = 'Country'))
d <- filter(dat, Date == date)
if (variable == 'StringencyIndex') {
title <- 'Stringency of Lockdown Across the World'
legend_title <- 'Stringency Index'
d$variable <- d$StringencyIndexForDisplay
} else if (variable == 'Deaths') {
title <- 'Confirmed Deaths per Million Across the World'
legend_title <- 'Deaths per Million'
d$variable <- d$DeathsPerMillion
} else if (variable == 'Cases') {
title <- 'Confirmed Cases per Million Across the World'
legend_title <- 'Cases per Million'
d$variable <- d$CasesPerMillion
}
plot_ly(data = d, type = "choropleth", locations = d$CountryCode, z = d$variable,
text = paste0(d$CountryName)) %>%
colorbar(title = legend_title, x = 0.5) %>%#, x = 0.5, xanchor = "center", y = 1.5) %>%
layout(title = title) %>%
layout(geo = list(lataxis = list(range = c(-35, 150))))
# layout(legend = list(orientation = "h",
#                      xanchor = "center",
#                      x = 0.5))
#add_trace(color = ~variable, type = "choropleth", locations = unique(CountryName))
# ggplot(d, aes(x = long, y = lat)) +
#   geom_polygon(aes(group = group, fill = variable)) +
#   scale_fill_viridis_c(option = 'plasma', limits = c(0, 100), name = legend_title) +
#   scale_x_continuous(expand = c(0, 0)) +
#   scale_y_continuous(expand = c(0, 0)) +
#   ggtitle(title) +
#   theme_bw() +
#   theme(
#     legend.position = 'top',
#     axis.title = element_blank(),
#     axis.text = element_blank(),
#     axis.ticks = element_blank(),
#     panel.grid.minor = element_blank(),
#     panel.grid.major = element_blank(),
#     plot.title = element_text(hjust = 0.5)
#   )
}
plot_world_data(world, dat, "2020-04-23", "StringencyIndex")
#' Returns ggplot of map filled according to variable
#' TODO: Change this to a fast plotly implementation (instead of calling ggplotly on the result)
#' TODO: Scale Deaths and Cases differently for sound visualisation
#'
#' @param world world data
#' @param sdat stringency data
#' @param date date for the stringency index
#' @param variable variable which should be shown
#' @returns ggplot object
plot_world_data <- function(world, dat, date, variable) {
#d <- left_join(world, filter(dat, Date == date), by = c('region' = 'Country'))
d <- filter(dat, Date == date)
if (variable == 'StringencyIndex') {
title <- 'Stringency of Lockdown Across the World'
legend_title <- 'Stringency Index'
d$variable <- d$StringencyIndexForDisplay
} else if (variable == 'Deaths') {
title <- 'Confirmed Deaths per Million Across the World'
legend_title <- 'Deaths per Million'
d$variable <- d$DeathsPerMillion
} else if (variable == 'Cases') {
title <- 'Confirmed Cases per Million Across the World'
legend_title <- 'Cases per Million'
d$variable <- d$CasesPerMillion
}
plot_ly(data = d, type = "choropleth", locations = d$CountryCode, z = d$variable,
text = paste0(d$CountryName)) %>%
colorbar(title = legend_title, y = 0.8) %>%#, x = 0.5, xanchor = "center", y = 1.5) %>%
layout(title = title) %>%
layout(geo = list(lataxis = list(range = c(-35, 150))))
# layout(legend = list(orientation = "h",
#                      xanchor = "center",
#                      x = 0.5))
#add_trace(color = ~variable, type = "choropleth", locations = unique(CountryName))
# ggplot(d, aes(x = long, y = lat)) +
#   geom_polygon(aes(group = group, fill = variable)) +
#   scale_fill_viridis_c(option = 'plasma', limits = c(0, 100), name = legend_title) +
#   scale_x_continuous(expand = c(0, 0)) +
#   scale_y_continuous(expand = c(0, 0)) +
#   ggtitle(title) +
#   theme_bw() +
#   theme(
#     legend.position = 'top',
#     axis.title = element_blank(),
#     axis.text = element_blank(),
#     axis.ticks = element_blank(),
#     panel.grid.minor = element_blank(),
#     panel.grid.major = element_blank(),
#     plot.title = element_text(hjust = 0.5)
#   )
}
plot_world_data(world, dat, "2020-04-23", "StringencyIndex")
#' Returns ggplot of map filled according to variable
#' TODO: Change this to a fast plotly implementation (instead of calling ggplotly on the result)
#' TODO: Scale Deaths and Cases differently for sound visualisation
#'
#' @param world world data
#' @param sdat stringency data
#' @param date date for the stringency index
#' @param variable variable which should be shown
#' @returns ggplot object
plot_world_data <- function(world, dat, date, variable) {
#d <- left_join(world, filter(dat, Date == date), by = c('region' = 'Country'))
d <- filter(dat, Date == date)
if (variable == 'StringencyIndex') {
title <- 'Stringency of Lockdown Across the World'
legend_title <- 'Stringency Index'
d$variable <- d$StringencyIndexForDisplay
} else if (variable == 'Deaths') {
title <- 'Confirmed Deaths per Million Across the World'
legend_title <- 'Deaths per Million'
d$variable <- d$DeathsPerMillion
} else if (variable == 'Cases') {
title <- 'Confirmed Cases per Million Across the World'
legend_title <- 'Cases per Million'
d$variable <- d$CasesPerMillion
}
plot_ly(data = d, type = "choropleth", locations = d$CountryCode, z = d$variable,
text = paste0(d$CountryName)) %>%
colorbar(title = legend_title, y = 0.6) %>%#, x = 0.5, xanchor = "center", y = 1.5) %>%
layout(title = title) %>%
layout(geo = list(lataxis = list(range = c(-35, 150))))
# layout(legend = list(orientation = "h",
#                      xanchor = "center",
#                      x = 0.5))
#add_trace(color = ~variable, type = "choropleth", locations = unique(CountryName))
# ggplot(d, aes(x = long, y = lat)) +
#   geom_polygon(aes(group = group, fill = variable)) +
#   scale_fill_viridis_c(option = 'plasma', limits = c(0, 100), name = legend_title) +
#   scale_x_continuous(expand = c(0, 0)) +
#   scale_y_continuous(expand = c(0, 0)) +
#   ggtitle(title) +
#   theme_bw() +
#   theme(
#     legend.position = 'top',
#     axis.title = element_blank(),
#     axis.text = element_blank(),
#     axis.ticks = element_blank(),
#     panel.grid.minor = element_blank(),
#     panel.grid.major = element_blank(),
#     plot.title = element_text(hjust = 0.5)
#   )
}
plot_world_data(world, dat, "2020-04-23", "StringencyIndex")
plot_ly(data = d, type = "choropleth", locations = d$CountryCode, z = d$variable,
text = paste0(d$CountryName)) %>%
colorbar(title = legend_title) %>%#, x = 0.5, xanchor = "center", y = 1.5) %>%
layout(title = title) %>%
layout(geo = list(lataxis = list(range = c(-35, 150))))
#' Returns ggplot of map filled according to variable
#' TODO: Change this to a fast plotly implementation (instead of calling ggplotly on the result)
#' TODO: Scale Deaths and Cases differently for sound visualisation
#'
#' @param world world data
#' @param sdat stringency data
#' @param date date for the stringency index
#' @param variable variable which should be shown
#' @returns ggplot object
plot_world_data <- function(world, dat, date, variable) {
#d <- left_join(world, filter(dat, Date == date), by = c('region' = 'Country'))
d <- filter(dat, Date == date)
if (variable == 'StringencyIndex') {
title <- 'Stringency of Lockdown Across the World'
legend_title <- 'Stringency Index'
d$variable <- d$StringencyIndexForDisplay
} else if (variable == 'Deaths') {
title <- 'Confirmed Deaths per Million Across the World'
legend_title <- 'Deaths per Million'
d$variable <- d$DeathsPerMillion
} else if (variable == 'Cases') {
title <- 'Confirmed Cases per Million Across the World'
legend_title <- 'Cases per Million'
d$variable <- d$CasesPerMillion
}
plot_ly(data = d, type = "choropleth", locations = d$CountryCode, z = d$variable,
text = paste0(d$CountryName)) %>%
colorbar(title = legend_title) %>%#, x = 0.5, xanchor = "center", y = 1.5) %>%
layout(title = title) %>%
layout(geo = list(lataxis = list(range = c(-35, 150))))
# layout(legend = list(orientation = "h",
#                      xanchor = "center",
#                      x = 0.5))
#add_trace(color = ~variable, type = "choropleth", locations = unique(CountryName))
# ggplot(d, aes(x = long, y = lat)) +
#   geom_polygon(aes(group = group, fill = variable)) +
#   scale_fill_viridis_c(option = 'plasma', limits = c(0, 100), name = legend_title) +
#   scale_x_continuous(expand = c(0, 0)) +
#   scale_y_continuous(expand = c(0, 0)) +
#   ggtitle(title) +
#   theme_bw() +
#   theme(
#     legend.position = 'top',
#     axis.title = element_blank(),
#     axis.text = element_blank(),
#     axis.ticks = element_blank(),
#     panel.grid.minor = element_blank(),
#     panel.grid.major = element_blank(),
#     plot.title = element_text(hjust = 0.5)
#   )
}
plot_world_data(world, dat, "2020-04-23", "StringencyIndex")
#' Returns ggplot of map filled according to variable
#' TODO: Change this to a fast plotly implementation (instead of calling ggplotly on the result)
#' TODO: Scale Deaths and Cases differently for sound visualisation
#'
#' @param world world data
#' @param sdat stringency data
#' @param date date for the stringency index
#' @param variable variable which should be shown
#' @returns ggplot object
plot_world_data <- function(world, dat, date, variable) {
#d <- left_join(world, filter(dat, Date == date), by = c('region' = 'Country'))
d <- filter(dat, Date == date)
if (variable == 'StringencyIndex') {
title <- 'Stringency of Lockdown Across the World'
legend_title <- 'Stringency Index'
d$variable <- d$StringencyIndexForDisplay
} else if (variable == 'Deaths') {
title <- 'Confirmed Deaths per Million Across the World'
legend_title <- 'Deaths per Million'
d$variable <- d$DeathsPerMillion
} else if (variable == 'Cases') {
title <- 'Confirmed Cases per Million Across the World'
legend_title <- 'Cases per Million'
d$variable <- d$CasesPerMillion
}
plot_ly(data = d, type = "choropleth", locations = d$CountryCode, z = d$variable,
text = paste0(d$CountryName)) %>%
colorbar(title = legend_title, limits = c(0, 100)) %>%#, x = 0.5, xanchor = "center", y = 1.5) %>%
layout(title = title) %>%
layout(geo = list(lataxis = list(range = c(-35, 150))))
# layout(legend = list(orientation = "h",
#                      xanchor = "center",
#                      x = 0.5))
#add_trace(color = ~variable, type = "choropleth", locations = unique(CountryName))
# ggplot(d, aes(x = long, y = lat)) +
#   geom_polygon(aes(group = group, fill = variable)) +
#   scale_fill_viridis_c(option = 'plasma', limits = c(0, 100), name = legend_title) +
#   scale_x_continuous(expand = c(0, 0)) +
#   scale_y_continuous(expand = c(0, 0)) +
#   ggtitle(title) +
#   theme_bw() +
#   theme(
#     legend.position = 'top',
#     axis.title = element_blank(),
#     axis.text = element_blank(),
#     axis.ticks = element_blank(),
#     panel.grid.minor = element_blank(),
#     panel.grid.major = element_blank(),
#     plot.title = element_text(hjust = 0.5)
#   )
}
plot_world_data(world, dat, "2020-04-23", "StringencyIndex")
quantile(dat$CasesPerMillion, .99)
quantile(dat$CasesPerMillion, .99, na.rm = FALSE)
quantile(dat$CasesPerMillion, .99, na.rm = TRUE)
max(dat$CasesPerMillion, na.rm = TRUE)
shiny::runApp()
library(shinydashboard)
library(shinyWidgets)
runApp()
library(shiny)
runApp()
source('helpers.R')
runApp()
